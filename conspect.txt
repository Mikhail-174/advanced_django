GIT:
Настройка Git
Перед началом работы с Git рекомендуется настроить ваше имя пользователя и адрес электронной почты. Эти данные будут использоваться для подписи ваших коммитов. Выполните следующие команды:

git config --global user.name "Ваше имя"
git config --global user.email "ваша_почта@example.com"

Иногда может потребоваться переименовать ветку. Для этого используется команда:

git branch -m <имя_ветки> <новое_имя_ветки>


Если переименовывается текущая ветка, то её имя можно не указывать:

git branch -m <новое_имя_ветки>

После того, как ветка слита в основную, её можно удалить. Для этого используется команда:

git branch -d <имя_ветки>


Если ветка не слита, для удаления нужно использовать команду:

git branch -D <имя_ветки>


Используйте -D с осторожностью, так как это удаляет ветку без предупреждений.


Просмотр удаленных репозиториев:

Команда: git remote -v
Описание: Эта команда выводит список всех удаленных репозиториев, связанных с вашим локальным репозиторием, включая их URL-адреса и типы (fetch и push).

Команда: git remote remove <имя>
Описание: Удаляет указанный удаленный репозиторий из вашего локального репозитория.
Пример:
git remote remove origin

Конфликты: Если у вас и других разработчиков есть изменения в одних и тех же файлах, при выполнении git pull могут возникнуть конфликты слияния. Git отметит эти конфликты в файлах, и вам нужно будет вручную их разрешить, отредактировав файлы и добавив их в индекс (git add) перед коммитом.
Ветки: Убедитесь, что вы работаете на правильной ветке (git checkout <ветка>). Обычно изменения отправляются в ту же ветку на удаленном репозитории.
Права доступа: Вам должны быть предоставлены права доступа к записи в удаленный репозиторий, чтобы отправлять изменения (git push).

2й Модуль
Добавил PostgreSQL в переменные среды:
    Откройте Параметры Windows (Win + I)
    Перейдите в: Система → О системе → Дополнительные параметры системы (внизу)
    Во вкладке Дополнительно нажмите Переменные среды
    В разделе Системные переменные найдите переменную Path и выберите Изменить
    Нажмите Создать и добавьте путь (например: C:\Program Files\PostgreSQL\17\bin)
    Нажмите OK во всех окнах
    Перезапустил PyCharm - т.к. не обновлялся терминал

psql -h localhost -p 5432 -U django_orm -d django_orm_db -подключение к серверу бд, предварительно создал пользователя и бд, хост указан в свойствах сервера - connections - host name
CREATE USER hr WITH PASSWORD '251125';
pip install "psycopg[binary]"

Чтобы в дальнейшем, для взаимодействия с таблицей hr_employee можно было запустить команду shell_plus, которая идет в пакете django-extensions, установим этот пакет:
pip install django-extensions


Если нам нужно вернуться к миграции 0005 из миграции 0006, мы выполним следующую команду:
python manage.py migrate hr 0005 или: python manage.py migrate hr 0005_second_last_migration

Если нам нужно отменить все миграции приложения hr, мы воспользуемся следующей командой:
python manage.py migrate hr zero



Помните, что иногда миграция может быть необратимой. Как правило, это состояние возникает, когда в модели Django были внесены некоторые существенные изменения. Когда мы попытаемся вернуться к такой миграции, Django выдаст IrreversibleError.


Если нам нужно полностью очистить всю базу данных, мы можем использовать следующую команду:
python manage.py flush


default - значение по умолчанию, записываемое в поле, если в него явно не было занесено никакого значения. Может быть указано двумя способами:
Как обычное значение любого неизменяемого типа:
is_active = models.BooleanField(default=True)
Если в качестве значения по умолчанию должно выступать значение изменяемого типа (список или словарь Python), то для его указания следует использовать второй способ.
Как ссылка на функцию, вызываемую при создании каждой новой записи и возвращающую в качестве результата заносимое в поле значение:
def is_active_default():
    return not is_all_posts_passive
...
...
is_active = models.BooleanField(default=is_active_default)

unique_for_date - если в этом параметре указать представленное в виде строки имя поля даты (DateField) или даты и времени (DateTimeField), то текущее поле может хранить только значения, уникальные в пределах даты, которая хранится в указанном поле. Пример:
title = models.CharField(max_length=50, unique_for_date='published')
published = models.DateTimeField()
В этом случае Django позволит сохранить в поле title только значения, уникальные в пределах даты, хранящейся в поле published;
unique_for_month - то же самое, что и unique_for_date, но в расчет принимается не всё значение даты, а лишь месяц;
unique_for_year - то же самое, что и unique_for_date, но в расчет принимается не всё значение даты, а лишь год;

editаblе - если True, то поле будет выводиться на экран в составе формы, если False - не будет (даже если явно создать его в форме) . По умолчанию - True;
db_column - имя поля таблицы в виде строки. Если не указано, то поле таблицы получит такое же имя, что и поле модели.


class Employee(models.Model):
    class Workplace(models.IntegerChoices):
        JOB_1 = 1, 'Junior'
        JOB_2 = 2, 'Middle'
        JOB_3 = 3, 'Senior'
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    workspace = models.PositiveSmallIntegerField(choices=Workplace.choices, default=Workplace.JOB_1,
    help_text="Position in the company?")
Мы создали класс Choice (перечисление) Workplace, который имеет 3 "уровня работников". Первая часть (например, JOB_1) — это имя  перечисления. Вторая часть (например, 1) является фактическим значением. Третья часть (например. 'Junior') представляет собой удобочитаемое имя, метку. Это то, что вы увидите в админке.
Класс Choices имеет два подкласса — IntegerChoicesи TextChoices. Поскольку нас интересуют только номера "уровней работников", мы использовали IntegerChoices(неважно, что имена констант и метки строковые, вы выбираете тип на основе значений).

python manage.py shell_plus --print-sql

Вторым параметром on_delete указывается поведение фреймворка в случае, если будет выполнена попытка удалить запись первичной модели, на которую ссылаются какие-либо записи вторичной модели. Параметру присваивается значение одной
из переменных, объявленных в модуле django.db.models:
CASCADE - удаляет все связанные записи вторичной модели (каскадное удаление);
PROTECT - возбуждает исключение ProtectedError из модуля django.db.models, тем самым предотвращая удаление записи первичной модели;
SET_NULL - заносит в поле внешнего ключа всех связанных записей вторичной модели значение null. Сработает только в том случае, если поле внешнего ключа объявлено необязательным к заполнению на уровне базы данных (параметр null конструктора поля имеет значение True);
SET_DEFAULT - заносит в поле внешнего ключа всех связанных записей вторичной модели заданное для него значение по умолчанию. Сработает только в том случае, если у поля внешнего ключа было указано значение по умолчанию (оно задается параметром default конструктора поля);
SET(<значение>) - заносит в поле внешнего ключа указанное значение:
department = models.ForeignKey(Department, on_delete=models.SET(1))
Также можно указать ссылку на функцию, не принимающую параметров и возвращающую значение, которое будет записано в поле:
def get_first_department():
    return Department.objects.first()
department = models.ForeignKey(Department, on_delete=models.SET(get_first_department))
DO_NOTHING - ничего не делает.

Из-за асимметричности отношений нам необходимо использовать Django метод <object>_set(). Он возвращает QuerySet, например employee_set вернет всех сотрудников отдела:
d = Department.objects.get(id=1)
d.employee_set.all()
Обратите внимание, что мы не определяли employee_set свойство в Department модели. Внутри Django автоматически добавил employee_set свойство в Departmentмодель, когда мы определили отношение «один-ко-многим» с помощью ForeignKey.
Метод employee_set.all() возвращает QuerySet, который содержит всех сотрудников, принадлежащих к отделу.


С помощью следующего кода, мы можем получить первого сотрудника:
e = Employee.objects.first()
Для доступа к отделу первого сотрудника вы используете атрибут department:
e.department
В этом случае Django все также выполняет два запроса. Первый запрос выбирает первого сотрудника, а второй запрос выбирает отдел выбранного сотрудника. Эти запросы можно оптизимизировать используя метод select_related().


Класс ForeignKey поддерживает следующие дополнительные необязательные параметры:
limit_choices_to - позволяет вывести в раскрывающемся списке записей первичной модели, отображаемом в веб-форме, только записи, удовлетворяющие заданным критериям фильтрации. Критерии фильтрации записываются в виде словаря Python, имена элементов которого совпадают с именами полей первичной модели, по которым должна выполняться фильтрация, а значения элементов укажут значения для этих полей. Выведены будут записи, удовлетворяющие всем критериям, заданным в таком словаре (т.е. критерии объединяются по правилу логического И). Мы можем добавить в модель Department новое поле actions. И после укажем Django выводить только рубрики, поле actions которых содержит значение True:
department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None, limit_choices_to={'actions': True})

related_name - имя атрибута записи первичной модели, предназначенного для доступа к связанным записям вторичной модели, в виде строки. По умолчанию обратное отношение будет называться ****_set.
Однако вы можете изменить имя обратного отношения с помощью атрибута related_name.
    department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None, related_name='test')
Если доступ из записи первичной модели к связанным записям вторичной модели не требуется, можно указать Django не создавать такой атрибут. Для этого достаточно присвоить параметру related_name = "+". Если параметр не указан, то атрибут такого рода получит стандартное имя вида <имя связанной вторичной модели>_sеt

related_query_name - имя фильтра, которое будет применяться во вторичной модели для фильтрации по значениям из записи первичной модели:
department = models.ForeignKey(Department, on_delete=models.CASCADE, default=None, related_query_name='entry')

to_field - имя поля первичной модели, по которому будет выполнена связь, в виде строки . Такое поле должно быть помечено как уникальное (параметр unique конструктора должен иметь значение True). Если параметр не указан, связывание выполняется по ключевому полю первичной модели - неважно, созданному явно или не явно;

db_constraint - если True, то в таблице базы данных будет создана связь, позволяющая сохранять ссылочную целостность, если False, ссылочная целостность будет поддерживаться только на уровне Django. Значение по умолчанию - True. Менять его на False имеет смысл, только если модель создается на основе уже существующей базы с некорректными данными.



Внешний ключ employee_id ссылается на id таблицы hr_employee, а compensation_id соответственно на id таблицы hr_compensations.
Как правило, вам не нужен столбец id в таблице hr_employee_compensations в качестве первичного ключа , и вы можете использовать оба employee_id и compensation_id в качестве составного первичного ключа. Однако Django всегда создает столбец id в качестве первичного ключа для таблицы соединения.
Кроме того, Django создает уникальное ограничение , включающее столбцы employee_id и compensation_id. Другими словами, в таблице не будет повторяющихся пар employee_id и compensation_id значений hr_employee_compensations.


Добавление оплаты сотрудникам
Сначала зарегистрируйте сотрудника John Doe в компенсационных программах stock (c1) и bonuses (c2), используя метод add() атрибута compensations:
e.compensations.add(c1)
e.compensations.add(c2)
Во-вторых, необходимо получить доступ ко всей compensations программе с John Doe использованием метода all() атрибута compensations:
e.compensations.all()

Django позволяет вам запрашивать отношения. Например, вы можете найти всех сотрудников, у которых есть компенсация с идентификатором 1:
Employee.objects.filter(compensations__id=1)
Или с именем "Profit Sharing":
Employee.objects.filter(compensations__name="Profit Sharing")

Снятие связи зарплат с сотрудников
Для снятия зарплатной программы с работника используется метод remove() атрибута compensations объекта Employee. Например:
Сначала найдите сотрудника, имя которого Jane Doe:
e = Employee.objects.filter(first_name='Jane', last_name='Doe').first()
e.compensations.remove(c3)



Конструктор класса ManyToManyField поддерживает дополнительные необязательные параметры limit_choices_to, related_name, related_query_name и db_constraint, описанные в предыдущем разделе , а также следующие:
symmetrical - используется только в тех случаях, когда модель связывается сама с собой. Если True, Django создаст симметричную связь, действующую в обоих направлениях. Если False, то связь будет асимметричной. Значение по умолчанию - True. Для асимметричной связи Django создаст в классе модели атрибут для доступа к записям связанной модели в обратном направлении.
through - класс модели, которая представляет связующую таблицу (связующая модель) либо в виде ссылки, либо в виде имени, представленном строкой. Если класс не указан, то связующая таблица будет создана самим Django. При использовании связующей модели нужно иметь в виду следующее, что в связующей модели следует явно объявить поля внешних ключей для установления связи с обеими связываемыми моделями: и ведущей, и ведомой;
Например если мы используем модель:
from django.db import models
class Student(models.Model):
    name = models.CharField(max_length=200)
class Course(models.Model):
    name = models.CharField(max_length=200)
    students = models.ManyToManyField(Student, through='Register')
class Register(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
    date = models.DateField()

through_fields - используется, если связь устанавливается через связующую модель, записанную в параметре through конструктора. Указывает поля внешних ключей, по которым будет создаваться связь. Значение параметра должно представлять собой кортеж из двух элементов: имени поля ведущей модели и имени поля ведомой модели, записанных в виде строк. Если параметр не указан, то поля будут созданы самим фреймворком. Например если мы используем модель:
from django.db import models
class Student(models.Model):
    name = models.CharField(max_length=200)
class Course(models.Model):
    name = models.CharField(max_length=200)
    students = models.ManyToManyField(Student, through='Register', through_fields=('course', 'student'))
class Register(models.Model):
    student = models.ForeignKey(Student, related_name='student', on_delete=models.CASCADE)
    intern = models.ForeignKey(Student, related_name='intern', on_delete=models.CASCADE)
    course = models.ForeignKey(Course, on_delete=models.CASCADE)
    date = models.DateField()
В приведенном выше примере модель Register имеет два внешних ключа Student у полей student и intern, теперь Django не знает, какой из них использовать, и в результате не сможет создать таблицы. В этом случае вы должны явно указать, какие внешние ключи Django должен использовать с помощью through_fields.

db_table - имя связующей таблицы. Обычно применяется, если связующая модель не используется. Если оно не указано, то связующая таблица получит имя по умолчанию.

Ключевые характеристики QuerySets:
Ленивая оценка (Lazy evaluation): QuerySet не выполняет запрос к базе данных до тех пор, пока вы не попытаетесь получить доступ к его данным (например, с помощью цикла for, индексации или вызова метода, возвращающего данные). Это позволяет оптимизировать работу с данными, особенно когда вам нужен только небольшой поднабор данных.
Итерируемость: QuerySet можно использовать в циклах for для итерации по полученным объектам.
Цепочки методов: QuerySets поддерживают цепочки методов (методы, которые возвращают новый QuerySet). Это позволяет создавать сложные запросы к базе данных в читаемом и понятном виде. Например: Post.objects.filter(published=True).order_by('-published_date')
Кэширование: QuerySets кэшируют результаты, чтобы избежать повторных обращений к базе данных, если вы несколько раз запрашиваете одни и те же данные.
Представление данных: QuerySets возвращают объекты Python, соответствующие вашей модели. Это позволяет легко работать с данными, используя атрибуты модели.


етоды возвращающие QuerySet
filter(): Фильтр по заданным параметрам поиска. Несколько  параметров объединяются операторами SQL AND.
exclude(): Фильтр по объектам, которые не соответствуют заданным параметрам поиска.
annotate(): Аннотирует каждый объект в QuerySet. Аннотации могут быть простыми значениями, ссылкой на поле или агрегированным выражением.
alias(): То же, что annotate(), но вместо аннотирования объектов в QuerySet, сохраняет выражение для последующего повторного использования с другими QuerySet методами.
order_by(): Изменение сортировки QuerySet по умолчанию.
reverse(): Сортирует QuerySet по умолчанию в обратном порядке.
distinct(): Выполнение SQL запроса SELECT DISTINCT для устранения дублирующихся строк.
values(): Возвращает словари вместо экземпляров моделей.
values_list(): Возвращает кортежи вместо экземпляров модели.
dates(): Возвращает QuerySet, содержащий все доступные даты в указанном диапазоне дат.
datetimes(): Возвращает QuerySet, содержащий все доступные даты в указанном диапазоне дат и времени.
none(): Создает пустой QuerySet.
all(): Возвращает копию текущего QuerySet-а.
union(): Использует SQL оператор UNION для объединения двух или более QuerySet.
intersection(): Использует SQL оператор INTERSECT для возврата общих элементов двух или более QuerySet.
difference(): Использует SQL оператор EXCEPT для возврата элементов первичного QuerySet которых нет в других.
select_related(): Выборка всех связанных данных при выполнении запроса (за исключением отношений многие-ко-многим).
prefetch_related(): Выборка всех связанных данных при выполнении запроса related()(включая отношения многие-ко-многим).
extra(): Метод используется для переименования столбцов в ORM.
defer(): Не извлекает указанные поля из БД. Используется для улучшения производительности запросов со сложными наборами данных.
only(): Противоположность метода defer() - возвращает только указанные поля.
using(): Выбирает, в какой базе данных будет оцениваться QuerySet(при использовании нескольких баз данных).
select_for_update(): Возвращает QuerySet и блокирует строки таблицы до завершения транзакции.
raw(): Выполняет исходный SQL оператор.
&: Комбинирует два QuerySet с помощью SQL оператора AND.
|: Комбинирует два QuerySet с помощью SQL оператора OR.
^: Комбинирует два QuerySet с помощью SQL оператора XOR.


annotate()
Метод annotate() позволяет добавлять вычисляемые атрибуты к объектам в QuerySet. Эти атрибуты не хранятся в базе данных, а вычисляются "на лету". Аннотации могут быть простыми значениями, ссылкой на поле или агрегированным выражением.
Имена вычисляемых атрибутов задаются через именованные аргументы, передаваемые в данный метод, например при такой аннотации:
Model.objects.annotate(my_attr_name=expr)
К каждому объекту в QuerySet будет добавлен атрибут my_attr_name со значением, полученным в результате вычисления выражения expr.
Метод annotate() часто используется с агрегационными функциями (такими как Sum, Avg, Count) для вычисления значений на основе связанных объектов. При этом можно не задавать имя для вычисляемого атрибута, оно будет сгенерировано на основе имени поля или поискового выражения по полю (переданного в данную функцию) и имени функции, например при такой аннотации:
Model.objects.annotate(Count('field'))
К каждому объекту в QuerySet будет добавлен атрибут field__count со значением, полученным в результате вычисления выражения Count('field').
Если в метод annotate() передаются выражения с заданием имени вычисляемого атрибута и без, то сначала необходимо указывать выражения без задания имени (позиционные аргументы), а только затем с заданием (именованные аргументы).
Model.objects.annotate(Count('field'), my_attr_name=expr)
Вычисляемые атрибуты можно использовать с другими QuerySet методами, например фильтровать по ним или сортировать.
Давайте воспользуемся агрегационной функцией Django Count() для аннотирования нашей модели Employee для вычисления количества зарплатных программ у каждого работника:
e = Employee.objects.annotate(compensations_count=Count('compensations'))
for i in e:
    print(i.first_name, i.last_name, i.compensations_count)

exclude()
Можно исключить некоторые результаты из запроса с помощью метода exclude().
Employee.objects.exclude(first_name='John')


alias()
То же, что и метод annotate(), но вместо аннотирования объектов в QuerySet, сохраняет выражение для последующего повторного использования с другими QuerySet методами. Это полезно, когда результат самого выражения не нужен, но он используется для фильтрации, упорядочивания или как часть сложного выражения.
Например, если вы хотите найти работников с 2 и более чем зарплатными программами, вы можете сделать это:
Employee.objects.alias(compensations_count=Count('compensations')).filter(compensations_count__gte=2)
Метод alias() можно использовать вместе с методами annotate(), exclude(), filter(), order_by()и update().


Чтобы отсортировать случайным образом, вы можете использовать вопросительный знак ?:
Employee.objects.order_by('?')
Сортировка случайным образом с помощью метода order_by('?') может быть медленной и ресурсозатратной, в зависимости от используемой базы данных.


Также метод order_by() может упорядочивать по полю в связанной модели. Синтаксис поля — связанная модель, за которой следуют двойные символы подчеркивания и имя поля:
model.objects.order_by(related_model__field_name)

reverse()
Делает упорядочивание по умолчанию QuerySet в обратном порядке. Чтобы функция reverse() была использована, модель должна иметь упорядочивание по умолчанию (путем установки ordering в Meta-классе модели). Если модель не упорядочена, то сортировка возвращаемого QuerySet будет бессмысленной.

distinct()
Устраняет дубликаты данных из QuerySet. Создадим еще одного работника, который будет дублировать уже существующего сотрудника.
С помощью данного запроса мы можем не выводить сотрудников, у которых повторяются имена.
Employee.objects.all().distinct('first_name')


values()
Метод values() возвращает QuerySet словарей, в которых ключами будут имена полей, а значениями - их значения. Данный метод позволяет указать какие значения полей необходимо вернуть в результирующих словарях, для этого надо передать имена полей, в виде строк, в данный метод. Если в метод не было передано ни одного имени поля, то в результирующем словаре будут все поля, например:
Employee.objects.filter(id=1).values()
Кроме имён полей, можно передавать в данный метод и выражения, например:
Model.objects.values(my_key1=F('field1')*F('field2'), my_key2=Count('field3'))
При этом произойдёт добавление ключей в результирующие словари QuerySet, которые были переданы в данный метод в виде именованных аргументов. Это более удобный способ, чем использовать предварительное аннотирование, как в этом примере:
Model.objects.annotate(my_key1=F('field1')*F('field2'), my_key2=Count('field3')).values('my_key1', 'my_key2')



Метод values_list() возвращает QuerySet кортежей, в которых элементами будут значения полей. Как и метод values(), данный метод позволяет указать какие значения полей необходимо вернуть в результирующих кортежах, для этого надо передать имена полей, в виде строк, в данный метод. Полученные значения полей будут находиться в той же последовательности, что и имена полей, переданные в данный метод, например:
Employee.objects.filter(last_name='Doe').values_list('first_name', 'last_name')
Если в метод не было передано ни одного имени поля, то в результирующем кортеже будут значения всех полей, в той же последовательности, что и порядок следования полей в модели, например:
Employee.objects.filter(id=1).values_list()
Кроме имён полей, можно передавать в данный метод и выражения, например:
Model.objects.values_list(F('field1')*F('field2'), Count('field3'))
При запросе только одного поля можно передать в метод дополнительный аргумент flat=True, чтобы получить QuerySet, содержащий непосредственно значения этого поля, а не QuerySet с кортежами, которые содержат по одному элементу


dates() и datetimes()
Методы dates() и datetimes() позволяют возвращать, из базы данных, записи привязанные к определённому времени (например, все события, происходящие в конкретном месяце). Для метода dates() это ограничения времени по году, месяцу, неделе и дню. Для метода datetimes() добавляются ещё и ограничения по часам, минутам и секундам. Например:
Employee.objects.dates('created', 'day')


none()
Метод none() возвращает пустой набор данных в виде объекта EmptyQuerySet. Одно из применений метода none() - это когда вы не знаете, будут ли объекты, но не хотите при этом вызвать ошибку.


union()
Данный метод используется для объединения набора результатов двух или более наборов запросов. Наборы запросов могут быть из одной или разных моделей. Когда наборы запросов относятся к разным моделям, поля и их типы данных должны совпадать.



Попробуем на практике, выберем всех сотрудников, возрастом до 30 лет.
e1 = Employee.objects.filter(age__lte=30)
Теперь в другую переменную, выберем всех сотрудников, возрастом старше 30 лет.
e2 = Employee.objects.filter(age__gte=30)
И теперь мы можем объединить их, с помощью метода union.
e1.union(e2)
Но если мы попробуем
d = Department.objects.all()
e1.union(d)
То получим ошибку: django.db.utils.ProgrammingError: все запросы в UNION должны возвращать одинаковое число столбцов.  Операция объединения может быть выполнена только с наборами запросов, имеющими одинаковые поля и типы данных. Следовательно, наша последняя операция объединения столкнулась с ошибкой. Вы можете объединить две модели, если они имеют одинаковые поля или подмножество полей.
Employee.objects.values_list('last_name', 'age').union(Department.objects.values_list('name', 'id'))
Поскольку Employee и Department оба имеют поля одинакового типа, мы можем использовать values_list для ограничения выбранных полей, а затем выполнить объединение.


intersection()
Использует SQL оператор INTERSECT для возврата общих элементов двух или более QuerySet-ов. Действуют те же ограничения, как и на union().
Ниже, в примере, мы выбрали первым запросом всех сотрудников возрастом более 25 лет и вторым запросом всех сотрудников моложе 70 лет. И в дальнейшем объединили данные запросы через intersection().
e1 = Employee.objects.filter(age__gte=25)
e2 = Employee.objects.filter(age__lte=70)
e2.intersection(e1)


difference()
Использует оператор SQL EXCEPT для хранения только элементов, присутствующих в QuerySet. Это метод, который выводит только те данные из первого QuerySet, которых нет во втором QuerySet. Действуют те же ограничения, как и на union().
e1 = Employee.objects.filter(age__gte=25)
e2 = Employee.objects.filter(age__lte=70)
e1.difference(e2)



select_related()
В разделе 2.3 "Связь One-To-Many (Один-ко-многим)" мы уже столкнулись с тем, что при присоединении сотрудника к отделу, Django выполняет два запроса. Первый запрос выбирает первого сотрудника, а второй запрос выбирает отдел выбранного сотрудника. Если вы выберете N сотрудников, чтобы отобразить их на веб-странице, вам нужно выполнить N + 1 запрос, чтобы получить как сотрудников, так и их отделы. Первый запрос (1) выбирает N сотрудников, а N запросов выбирает N отделов для каждого сотрудника. Эта проблема известна как проблема запроса N + 1.
Чтобы решить проблему с запросом N + 1, вы можете использовать select_related() метод выбора как сотрудников, так и отделов с помощью одного запроса. Например:
Employee.objects.select_related('department').all()
В этом примере Django выполняет только один запрос, который объединяет таблицы hr_employee и hr_department.



prefetch_related()
Данный метод работает так же, как и select_related(), за исключением того, что он будет работать с отношениями many-to-many.
Employee.objects.prefetch_related('compensations').all()


extra()
Иногда синтаксис запроса Django сам по себе не может легко выразить сложное  предложение WHERE. Для этого был создан метод extra().
Employee.objects.extra(where=["first_name=%s"], params=["John"])
Employee.objects.extra(where=["last_name='Doe' OR first_name = 'John'"])
Что будет приравниваться к запросу:
SELECT * FROM hr_employee WHERE last_name='Doe' OR first_name = 'John'
Более подробно можно почитать в документации - https://docs.djangoproject.com/en/5.2/ref/models/querysets/#extra


defer()
Если в вашей модели Django есть поля, содержащие много данных, и вам не нужны эти поля для определенного запроса, вы можете указать Django не извлекать их с помощью метода defer(). Попробуем вывести первого работника.
Мы видим что у него есть поле 'created'. Попробуем извлечь первого работника используя метод defer чтобы не выводить их дату создания:
Employee.objects.defer('created')


using()
Если если в вашем проекте задействовано несколько баз данных, то этот метод позволит выбрать, какая база данных будет использоваться для запроса. Уникальный параметр этого метода является псевдонимом базы данных, определенным в базах данных.

# запрашивает базу данных 'default'.
>>> Entry.objects.all()
# запрашивает базу данных 'backup'
>>> Entry.objects.using('backup')
В settings.py проекта мы можем задать несколько баз данных и использовать их в зависимости от потребностей через данный метод.

select_for_update()
Метод select_for_update, предлагаемый Django ORM, решает проблему параллелизма, возвращая набор запросов, который блокирует все строки, принадлежащие этому набору запросов, до тех пор, пока самая внешняя транзакция, в которой он находится, не будет закончена, что предотвращает повреждение данных.
Employee.objects.select_for_update().get(id=1)


raw()
Если ваш API-интерфейс запроса модели не может выполнить определенные запросы или вы хотите повысить производительность, вы можете использовать необработанные SQL-запросы в Django. ORM(Object Relational Mapper) помогает преодолеть разрыв между базой данных и нашим кодом, выполняя необработанные запросы через метод raw().
Employee.objects.raw('select * FROM hr_employee')
Возвращает объект <RawQuerySet: select * FROM hr_employee>



AND (&)
Объединяет два запроса QuerySet с помощью оператора SQL AND аналогично цепочке фильтров.
Employee.objects.filter(id=1) & Employee.objects.filter(age__gt=0)
Employee.objects.filter(id=1).filter(age__gt=0)
Это два запроса, которые будут эквивалентны друг другу.


OR (|)
Объединяет два QuerySet с помощью оператора SQL OR.
Employee.objects.filter(id=1) | Employee.objects.filter(id=2)

XOR (^)
Объединяет два QuerySet с помощью оператора SQL XOR.
Employee.objects.filter(id=1) ^ Employee.objects.filter(age__gt=2)


Методы которые не возвращают QuerySet
get(): Возвращает один объект. Вызывает ошибку, если поиск возвращает несколько объектов.
create(): Быстрый метод создания и сохранения объекта за один шаг. Так же данный метод возвращает созданный объект.
get_or_create(): Возвращает один объект. Если объект не существует, то он его создает.
update_or_create(): Обновляет один объект. Если объект не существует, то он его создает.
bulk_create(): Вставляет список объектов в базу данных.
bulk_update(): Обновляет указанные поля в списке экземпляров модели.
count(): Подсчитывает количество объектов в возвращаемом QuerySet. Возвращает целое число.
in_bulk(): Возвращает словарь, содержащий все объекты с указанными ID.
iterator(): Выполнение QuerySet и возвращение итератора по результатам. Может улучшить производительность и потребление памяти при запросах, возвращающих большое количество объектов.
latest(): Возвращает последний объект в таблице базы данных на основе заданного поля (полей).
earliest(): Возвращает самый ранний объект в таблице базы данных на основе заданного поля (полей).
first(): Возвращает первый объект в соответствующем QuerySet.
last(): Возвращает последний объект в соответствующем QuerySet.
aggregate(): Возвращает словарь агрегированных значений (средние, суммы и т.д.), рассчитанных по QuerySet.
exists(): Возвращает True, если QuerySet содержит какие либо результаты.
contains(): Метод возвращает True, если набор QuerySet содержит определенный объект, и False - если не содержит.
update(): Выполняет SQL оператор UPDATE в указанном поле (полях).
delete(): Выполняет SQL оператор DELETE, удаляющий все строки в QuerySet.
as_manager(): Возвращает экземпляр класса Manager, содержащий копию методов QuerySet.
explain(): Возвращает строку плана выполнения QuerySet. Используется для анализа выполнения запросов.


get()
Метод get() возвращает один единственный объект. Если нет совпадения результатов, это вызовет исключение DoesNotExist. Если запросу get() соответствует более одного элемента, то это вызовет исключение MultipleObjects.
Employee.objects.get(id=1)

create()
Удобный метод создания объекта и его сохранения за один шаг. Асинхронная версия acreate()
Department.objects.create(name='Testing', description='Test Engineer')

get_or_create()
Данный метод будет пытаться извлечь запись, соответствующую полям поиска. Если записи не существует, то она будет создана. Возвращаемое значение будет кортежем, в котором будет содержаться созданный или извлеченный объект, а также булевым значением, которое будет True, если была создана новая запись:
>>> e, bool = Department.objects.get_or_create(name='Sys_Admin', description='System Administration Department')
>>> e
<Department: Sys_Admin>
>>> bool
True
Если мы попробуем повторить выполнение данного кода, то получим:
>>> e, bool = Department.objects.get_or_create(name='Sys_Admin', description='System Administration Department')
>>> e
<Department: Sys_Admin>
>>> bool
False
Также мы можем передать словарь с именем defaults, он позволяет вам указать значения для других полей модели, которые нужно установить при создании нового объекта, не дублируя код.
>>> e, bool = Department.objects.get_or_create(name='Sys_Admin', defaults={'description':'System Administration Department'})
Асинхронная версия - aget_or_create()

update_or_create()
Работает аналогично get_or_create(), вы также передаете поля поиска и словарь с именем defaults, содержащий поля для обновления. Если объект не существует, метод создаст новую запись в базе данных:
e, bool = Department.objects.update_or_create(name='Sys_Admin', description='System Administration Department', defaults={'name':'Sys admin'})
Асинхронная версия - aupdate_or_create()

bulk_create()
Метод bulk_create() экономит время, вставляя в базу данных сразу несколько объектов, чаще всего в одном запросе. Функция имеет один обязательный параметр - список объектов:
e = Department.objects.bulk_create([Department(name='Test_bulk', description='Test bulk_create'), Department(name='Test_bulk_2', description='Test bulk_create 2')])
Асинхронная версия - abulk_create()

bulk_update()
Метод bulk_update(), наоборот, берет список объектов модели и обновляет отдельные поля в выбранных экземплярах модели. Данный метод будет работать только со списком объектов, поэтому сначала нужно создать список объектов, который мы хотим обновить:
>>> e = Department.objects.filter(id__gt = 4)
>>> e
<QuerySet [<Department: Test_bulk>, <Department: Test_bulk_2>]>
Затем мы вносим изменения в объекты из списка:
>>> e_list = [e[0], e[1]]
>>> e_list[0].name = 'Test_bulk_update'
>>> e_list[1].name = 'Test_bulk_update_2'
После этого мы уже можем использовать метод bulk_update для сохранения изменений в базе данных в одном запросе:
>>> Department.objects.bulk_update(e_list, ['name'])
Асинхронная версия abulk_update()

count()
Подсчитывает количество объектов в QuerySet. Может использоваться для подсчета всех объектов в таблице базы данных:
>>> Employee.objects.count()
4
Или используется для подсчета количества объектов, возвращенных запросом:
>>> Employee.objects.filter(last_name='Doe').count()
2
Метод count() функционально эквивалентен использованию функции aggregate(), но count() имеет более чистый синтаксис и вероятно будет быстрее в больших наборах данных. Например:
>>> Employee.objects.all().aggregate(Count('id'))
{'id__count': 4}
Асинхронная версия метода - acount().

in_bulk()
Метод берет список значений id и возвращает словарь, с экземплярами объектов которые соответствуют каждому id. Если в список не передать значение, то будут возвращены все объекты:
Employee.objects.in_bulk()
После извлечения, вы можете получить доступ к каждому объекту по его ключевому значению:
Любой непустой список извлечет все записи с указанными id:
Employee.objects.in_bulk([1])
Список c id не обязательно должен быть последовательным:
Асинхронная версия - ain_bulk()

iterator()
QuerySet обычно кеширует свои результаты, когда происходит оценка, и для любых дальнейших операций с этим QuerySet он сначала проверяет кешированные результаты. Но когда вы используете iterator(), он не проверяет кеш и считывает результаты непосредственно из базы данных. Результаты не сохраняются в QuerySet.
Для QuerySet, возвращающего большое количество объектов, которые требуют много памяти для кеширования и к которому вам нужно получить доступ только один раз, вы можете использовать iterator().
Employee.objects.all().iterator()

first()
Возвращает первый объект, соответствующий набору запросов или None, если нет подходящего объекта. Если в наборе запросов порядок не определен, то набор запросов автоматически упорядочивается по первичному ключу.
Employee.objects.first()

last()
Возвращает последний объект, соответствующий набору запросов или None, если нет подходящего объекта. Если в наборе запросов порядок не определен, то набор запросов автоматически упорядочивается по первичному ключу.
Employee.objects.last()

earliest() и latest()
 Возвращает первый объект или последний объект, в порядке для указанного в методе поля(полей):
Employee.objects.latest('created')
Employee.objects.earliest('created')
Если в данном методе поле(поля) не указаны, то значение их берётся из атрибута get_latest_by класса Meta данной модели.
Данные методы можно рассматривать как эквиваленты методов order_by('поле').first() и order_by('поле').last(), но с отличием в том, что методы earliest() и latest() вызывают исключение DoesNotExist, если нет подходящего объекта.

aggregate()
Возвращает словарь агрегированных значений, вычисленных по QuerySet.
Department.objects.aggregate(Count('name'))

exists()
Возвращает True, если полученный QuerySet содержит один или несколько объектов, False, если QuerySet пустой.
Employee.objects.filter(first_name='Bill').exists()
В случае если ответ не содержит объекты, получим False

contains()
Метод contains() возвращает True, если QuerySet содержит определенный объект, и False - если не содержит:
e = Employee.objects.filter(first_name="John")
Employee.objects.filter(age__gte=35).contains(e)
>>> True
Асинхронная версия acontains()

update()
Еще один способ обновления объектов представляет метод update() в сочетании с методом filter (будет 1 запрос к БД):
Employee.objects.filter(age__lt=30).update(department=2)

В данном примере мы выбрали всех сотрудников моложе 30 лет и присвоили их к отделу с id = 2.
Асинхронная версия aupdate()

delete()
Для удаления мы можем вызвать метод delete() (либо его) у удаляемого объекта:
e = Employee.objects.get(id=1)
e.delete()

Если не требуется получение отдельного объекта из базы данных, тогда можно удалить объект с помощью комбинации методов filter() и delete():
Employee.objects.filter(age__lt=30).delete()
Асинхронная версия adelete()

as_manager()
Метод класса, возвращающий экземпляр Manager с копией QuerySet методов.

explain()
Этот метод возвращает строку анализа выполнения QuerySet. Используется для анализа производительности запросов.
Employee.objects.filter(age__lt=20).explain()

Полный список поисковых полей Django
exact/iexact    Точное совпадение. iexact - версия без учета регистра.
contains/icontains    Поле содержит текст поиска. icontains это версия без учета регистра.
in    В указанной итерации (список, кортеж или QuerySet)
gt/gte    Больше чем / больше чем или равно
lt/lte    Меньше чем/меньше чем или равно
startswith/istartswith    Начинается в строке поиска. istartswith это версия без учета регистра.
endswith/iendswith    Заканчивается в строке поиска. iendswith это версия без учета регистра.
range    Тест диапазона. Диапазон включает в себя начальное и конечное значения
date    Передает значение в виде даты. Используется для поиска полей datetime
year    Поиск точного совпадения года
iso_year    Поиск точного совпадения по году ISO 8601
month    Поиск точного совпадения месяца
day    Поиск точного совпадения дня
week    Поиск точного совпадения недели
week_day    Поиск точного совпадения дня недели
quarter    Поиск точного совпадения квартала года.
time    Использует значение времени. Используется для поиска полей datetime
hour/minute/second    Поиск точного совпадения по часам, минутам или секундам.
isnull    Проверяет, есть ли нулевое поле. Возвращает True или False
regex/iregex    Совпадение регулярных выражений. iregex - версия без учета регистра.

exact/iexact
Поиск exact используется для получения записей с указанным значением. Поиск exact чувствителен к регистру. Для поиска без учета регистра используйте поиск iexact.
Employee.objects.filter(first_name__exact='Jane')
Мы также можем осуществлять поиск по связанным таблицам:
Employee.objects.filter(first_name__exact='Jane', department__name__exact='IT')

contains/icontains
contains позволяет вам проверить, содержит ли строка подстроку. Это эквивалентно следующему оператору - LIKE:
LIKE '%substring%'

Например, следующий код находит сотрудников, чье имя содержит подстроку Bi:
Employee.objects.filter(first_name__contains='Bi')

Запрос возвращает сотрудника с именем Bill.
icontains это не чувствительная к регистру версия метода contains. Таким образом, вы можете использовать icontains чтобы проверить, содержит ли строка подстроку без учета регистра:
Employee.objects.filter(first_name__icontains='j')

in()
Оператор SQL IN возвращает значение True, если значение находится в наборе значений:
field_name IN (v1, v2, ...)
Например, вы можете использовать IN оператор для запроса строк из таблицы hr_employee, который находит значение department_id в списке, подобном этому:
SELECT *
FROM hr_employee
WHERE department_id IN (1,2,3)
В Django вы используете оператор in:
Employee.objects.filter(department_id__in=(1,2))
Обычно вы используете подзапрос с оператором in, а не список литеральных значений.

gt, gte, lt, lte
В Django для выполнения сравнений в запросах к базе данных используются следующие фильтры набора запросов:

gt(больше чем): Этот фильтр выбирает объекты, в которых указанное поле больше заданного значения. Например:
Employee.objects.filter(age__gt=30)
Этот запрос извлечет всех сотрудников, возраст которых (поле age) больше 30.

lt(меньше чем): этот фильтр выбирает объекты, в которых указанное поле меньше заданного значения. Например:
Employee.objects.filter(age__lt=30)
Этот запрос извлечет всех сотрудников, возраст которых (поле age) меньше 30.

gte(больше или равно): этот фильтр выбирает объекты, в которых указанное поле больше или равно заданному значению. Например:
Employee.objects.filter(age__gte=30)
Этот запрос извлечет всех сотрудников, возраст которых (поле age) больше или равно 30.

lte(меньше или равно): Этот фильтр выбирает объекты, в которых указанное поле меньше или равно заданному значению. Например:
Employee.objects.filter(age__lte=30)
Этот запрос извлечет всех сотрудников, возраст которых (поле age) меньше или равно 30.


startswith / istartswith
Иногда вам нужно проверить, начинается ли строка с подстроки. Например, вы можете найти сотрудников, чье имя начинается с символа "J".
Чтобы сделать это в SQL, вы используете оператор LIKE:
SELECT *
FROM hr_employee
WHERE first_name LIKE 'J%';
Это % подстановочный знак, который соответствует любому количеству символов. И выражение 'J%' соответствует строкам, которые начинаются с символа J и за которыми следует ноль или более символов.
Чтобы запросить данные из Django с помощью оператора LIKE, вы добавляете startswith к имени поля:
field_name__startswith
Например, следующий запрос использует это в методе filter() для поиска сотрудников, чьи имена начинаются с символа J:
Employee.objects.filter(first_name__startswith='J')
Если вы хотите найти сотрудников, чьи имена начинаются с символа J, без учета регистра, вы можете использовать регистронезависимую версию istartswith:
Employee.objects.filter(first_name__istartswith='j')
В этом случае __istartswith для сопоставления используется версия значения в верхнем регистре.

endswith/iendswith
Оператор endswith и iendswith возвращает QuerySet, если значение заканчивается подстрокой. endswith эквивалентен следующему SQL оператору - LIKE:
LIKE '%substring'
Например, в следующем примере endswith используется для поиска сотрудников, чьи имена заканчиваются на ne:
Employee.objects.filter(first_name__endswith='ne')
Метод iendswith, это нечувствительная к регистру версия метода endswith. Например:
Employee.objects.filter(first_name__iendswith='LL')

range()
В SQL вы используете оператор BETWEEN, чтобы проверить, находится ли значение между двумя значениями:
field_name BETWEEN low_value AND high_value
В Django эквивалентом оператора BETWEEN является фильтрация через следующий метод:
Entity.objects.filter(field_name__range=(low_value,high_value))
Например, вы можете найти сотрудников с id от 2 до 4, используя следующий диапазон:
Employee.objects.filter(id__range=(2,4))
Мы также можем использовать данный метод и с датами, например следующий запрос выведет всех сотрудников, которые были созданы в период между двух дат.
Employee.objects.filter(created__range=('2021-12-12', '2023-12-12'))

date()
При необходимости выборки сотрудников, которые были созданы в определенную дату, мы можем использовать следующий метод:
Employee.objects.filter(created__date=date(2023, 7, 14))
Все эти сотрудники были созданы в одну дату, 14.07.2023.

year()
Для выборки сотрудников, созданных в одном году мы можем использовать следующий метод:
Employee.objects.filter(created__year=2023)

iso_year()
Работает аналогично методу year(), принимает год в формате ISO 8601.
month, day, week, week_day, quarter
Метод month принимает точное совпадение месяца:
Employee.objects.filter(created__month=7)
Метод day предназначен для точного совпадения дня.
Метод  week    поиск точного совпадения недели.
Метод week_day   поиск точного совпадения дня недели.
Метод quarter   поиск точного совпадения квартала года.
Все данные методы работают аналогично методу month  и могут использоваться совместно с другими методами, например мы можем вывести всех сотрудников, созданных после 2001 года:
Employee.objects.filter(created__year__gt=2001)
time, hour/minute/second
С помощью данных методов мы можем фильтровать наши значения по времени, часам, минутам и секундам. Например следующий запрос выведет всех сотрудников, созданных после 12:00:
Employee.objects.filter(created__time__gt=datetime.time(12, 00))
Остальные методы(hour, minute, second) работают по такому же принципу и могут использоваться совместно с другими методами.

isnull()
В следующем примере используется isnull для получения сотрудников, у которых нет контактов:
Employee.objects.filter(contact_id__isnull=True)
Сгенерированный запрос использует оператор IS NULL для сравнения contact_id с NULL.
В следующем примере используется isnull для получения всех сотрудников, у которых есть контакты:
Employee.objects.filter(contact_id__isnull=False)
В этом случае сгенерированный запрос использует IS NOT NULL для сравнения значений в столбце contact_id с NULL.

regex/iregex
Данные методы задают регулярное выражение, которому должно соответствовать значение свойства модели. В случае с regex выборка зависит от регистра, а у iregex - не зависит от регистра.
Employee.objects.filter(first_name__regex=r"(hn|ne)$")
В данном случае мы хотим вывести всех сотрудников, у которых значение поля first_name оканчивается на "hn" или "ne".


Агрегатная функция принимает список значений и возвращает одно значение. Наиболее часто используемыми агрегатными функциями являются Count, Max, Min, Avg и Sum. Они предоставляются пакетом django.db.models.

Count()
Функция Count() возвращает количество содержащихся в данном столбце строк. Данная функция принимает столбец, для которого вы хотите получить количество строк. Например, вы можете использовать функцию Count() для получения количества сотрудников:
Employee.objects.aggregate(Count('id'))
Функция Count() использует SQL-функцию COUNT(), которая возвращает количество строк в столбце id таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__count', а в значении будет количество строк в этом столбце.
При необходимости можно задать своё имя ключа, например:
Employee.objects.aggregate(employees=Count('id'))
Так же можно подсчитывать отфильтрованные результаты, например чтобы получить количество сотрудников, чьи имена начинаются с Jo, для этого используется опциональный аргумент filter, который принимает Q-объект:
Employee.objects.aggregate(jo_employees=Count('id', filter=Q(first_name__startswith='Jo')))
Второй опциональный аргумент distinct используется для подсчёта строк только с уникальными значениями, для этого необходимо установить ему значение distinct=True.
Внимание: функция Count() при подсчете использует только не-NULL значения в столбце, кроме случая Count('*'), когда подсчитывается количество всех строк в таблице.

Max()
Функция Max() возвращает максимальное значение в наборе значений. Данная функция принимает столбец, для которого вы хотите получить наибольшее значение.
Например, в следующем примере функция Max() используется для возврата наибольшего возраста сотрудника:
Employee.objects.aggregate(Max('age'))
Функция Max() использует SQL-функцию MAX(), которая возвращает максимальное значение в столбце возраста age таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__max', а в значении будет максимальное значение в этом столбце.
Кроме опциональных аргументов filter и distinct, функция Max() принимает ещё два опциональных аргумента default и output_field.
Аргумент default задаёт значение, которое вернёт данная функция, если исходный кверисет будет пустым.
Аргумент output_field задаёт тип поля для возвращаемого значения, по умолчанию используется тот-же тип поля, что и в переданном в функцию поле. Но могут быть ситуации когда в функцию передаётся выражение на основе двух полей разных типов, например DecimalField и FloatField, тогда необходимо указать какой тип поля требуется на выходе функции, например output_field=DecimalField().

Min()
Функция Min() возвращает минимальное значение в наборе значений. Как функция Max(), функция Min() принимает столбец, для которого вы хотите получить наименьшее значение.
В следующем примере функция Min() используется для возврата наименьшего возраста сотрудника:
Employee.objects.aggregate(Min('age'))
Функция Min() использует SQL-функцию MIN(), которая возвращает минимальное значение в столбце возраста age таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__min', а в значении будет минимальное значение в этом столбце.
Как и функция Max(), функция Min() принимает опциональные аргументы filter, distinct, default и output_field.

Avg()
Функция Avg() возвращает среднее значение в наборе значений. Она принимает имя столбца и возвращает среднее значение всех значений в этом столбце:
Employee.objects.aggregate(Avg('age'))
Функция Avg() использует SQL-функцию AVG(), которая возвращает среднее значение в столбце возраста age таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__avg', а в значении будет среднее значение в этом столбце.
Функция Avg() так-же принимает опциональные аргументы filter, distinct, default и output_field.

Sum()
Функция Sum() возвращает сумму значений. Например, вы можете использовать функцию Sum() для расчета суммы возрастов сотрудников компании:
Employee.objects.aggregate(Sum('age'))
Функция Sum() использует SQL-функцию SUM(), которая возвращает сумму значений в столбце возраста age таблицы hr_employee.
В результате мы получим словарь, в котором ключом будет '<имя_столбца>__sum', а в значении будет сумма значений в этом столбце.
Функция Sum() так-же принимает опциональные аргументы filter, distinct, default и output_field.


В Django вы можете использовать метод annotate() для метода values(), применяя агрегацию к группам следующим образом:
Entity.objects.values('column_2').annotate(value=AGGREGATE('column_1'))
В этом синтаксисе;
values('column_2')– передать в метод values() столбец, который вы хотите сгруппировать.
annotate(value=AGGREGATE('column_1'))– указать, что агрегировать в методе annotate() .
Обратите внимание, что порядок вызова методов values() и annotate() имеет значение. Если вы не вызовете метод values() первым и annotate() вторым, выражение не будет давать агрегированные результаты.


1) Django Group By с примером Count
В следующем примере используются методы values() и  annotate() для получения количества сотрудников по отделам:
Employee.objects.values('department').annotate(head_count=Count('department')).order_by('department')
Сначала сгруппируем сотрудников по отделам с помощью метода values():
values('department')
Далее, применяется функция Count() к каждой группе:
annotate(head_count=Count('department'))
И в конце отсортируйте объекты в наборе QuerySet по отделам:
order_by('department')
За кулисами Django выполняет оператор SELECT с предложением GROUP BY:
SELECT "hr_employee"."department_id",
       COUNT("hr_employee"."department_id") AS "head_count"
  FROM "hr_employee"
 GROUP BY "hr_employee"."department_id"
 ORDER BY "hr_employee"."department_id" ASC
 LIMIT 21

2) Django Group By с примером Min, Max и Avg
В следующем примере несколько агрегатных функций применяются к группам, чтобы получить самый низкий, средний и самый высокий возраст сотрудников в каждом отделе:
Employee.objects.values('department').annotate(min_age=Min('age'), max_age=Max('age'), avg_age=Avg('age')).order_by('department')

3) Группировка Django с примером соединения связанных таблиц
В следующем примере используются методы values() и annotate() для получения количества сотрудников в каждом отделе:
Department.objects.values('name').annotate(head_count=Count('employee'))
Как это работает.
values('name') – группирует отделы по названию.
annotate(head_count=Count('employee')) – подсчитывает сотрудников в каждом отделе.
За кулисами Django использует LEFT JOIN для соединения hr_department таблицы с hr_employee таблицей и применения COUNT() функции к каждой группе.

4) Группировка Django и filter()
Чтобы применить условие к группам, вы используете метод filter(). Например, следующий пример использует метод filter() для получения отдела с количеством сотрудников более 1:
Department.objects.values('name').annotate(head_count=Count('employee')).filter(head_count__gt=1)
За кулисами Django использует SQL предложение HAVING для фильтрации группы на основе условия, которое мы передаем методу filter():
SELECT "hr_department"."name",
       COUNT("hr_employee"."id") AS "head_count"
  FROM "hr_department"
  LEFT OUTER JOIN "hr_employee"
    ON ("hr_department"."id" = "hr_employee"."department_id")
 GROUP BY "hr_department"."name"
HAVING COUNT("hr_employee"."id") > 1